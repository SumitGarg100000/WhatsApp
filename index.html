<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>RealChat AI Companion</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script>
        // In a real-world scenario, this would be managed by a build process (e.g., Vite, Create React App)
        // For this single-file setup, we'll define a placeholder.
        const process = {
            env: {
                // IMPORTANT: Replace this with your actual Gemini API key.
                // It's recommended to use environment variables in a real project for security.
                API_KEY: "AIzaSyDzNZjDRW2E6Q_ml1VcDtbv1fl2tGuPfD4",
                // Add your Google Custom Search API key and Engine ID here for tax search
                SEARCH_API_KEY: "YOUR_GOOGLE_SEARCH_API_KEY_HERE",  // Get from Google Cloud Console
                SEARCH_ENGINE_ID: "YOUR_SEARCH_ENGINE_ID_HERE"      // Create Programmable Search Engine
            }
        };
    </script>
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.3.1",
        "react-dom/client": "https://esm.sh/react-dom@18.3.1/client",
        "@google/genai": "https://esm.sh/@google/genai"
      }
    }
    </script>
<link rel="stylesheet" href="/index.css">
</head>
<body class="bg-gray-200">
    <div id="root"></div>
    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef, useCallback } from 'react';
        import ReactDOM from 'react-dom/client';
        import { GoogleGenAI } from "@google/genai";

        // --- TYPES ---
        const MessageSender = {
            USER: 'user',
            AI: 'ai',
        };

        const Relationship = {
            GIRLFRIEND: 'Girlfriend',
            BOYFRIEND: 'Boyfriend',
            WIFE: 'Wife',
            HUSBAND: 'Husband',
            FRIEND: 'Friend',
            BEST_FRIEND: 'Best Friend',
            COLLEAGUE: 'Colleague',
            PARTNER: 'Partner',
            TEACHER: 'Teacher',
            STUDENT: 'Student',
            CRUSH: 'Crush',
            LOVER: 'Lover',
        };

        const Personality = {
            INNOCENT: 'Innocent',
            CALM: 'Calm',
            CARING: 'Caring',
            TALKATIVE: 'Talkative',
            INTELLIGENT: 'Intelligent',
            CREATIVE_THINKER: 'Creative Thinker',
            SHY: 'Shy',
            MOODY: 'Moody',
            HUMOROUS: 'Humorous',
            SARCASTIC: 'Sarcastic',
            FLIRTY: 'Flirty',
            ROMANTIC: 'Romantic',
            NAUGHTY: 'Naughty',
            DIRTY_TALKER: 'Dirty Talker',
            DOMINANT: 'Dominant',
            SUBMISSIVE: 'Submissive',
            BAD_BOY: 'Bad Boy',
            BAD_GIRL: 'Bad Girl',
            POSSESSIVE: 'Possessive',
            JEALOUS: 'Jealous',
            SHORT_TEMPERED: 'Short Tempered',
            LESS_TALKATIVE: 'Less Talkative',
            UNDERSTANDABLE: 'Understandable',
            TAX_CONSULTANT: 'Tax Consultant',
            CODER: 'Coder',
            EXPERT_ALL_FIELDS: 'Expert in all fields',
        };

        const Gender = {
            MALE: 'Male',
            FEMALE: 'Female',
            OTHER: 'Other',
        };

        // --- GEMINI SERVICE ---
        const API_KEY = process.env.API_KEY;

        if (!API_KEY || API_KEY === "YOUR_GEMINI_API_KEY_HERE") {
            console.warn("API_KEY is not set. Please update the placeholder in index.html.");
        }

        const ai = new GoogleGenAI({ apiKey: API_KEY });

        // Debounce utility for delayed saves (5 min = 300000 ms)
        const debounceSave = (key, data, delay = 300000) => {
          let timeoutId;
          return () => {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => {
              try {
                localStorage.setItem(key, JSON.stringify(data));
                console.log(`Saved ${key} after ${delay / 1000 / 60} min idle.`);
                // Optional: Clear old chat messages here if needed (uncomment)
                // if (key === 'characters') {
                //   setCharacters(prev => prev.map(c => ({ ...c, messages: [] })));
                // }
              } catch (error) {
                console.error(`Save failed for ${key}:`, error);
              }
            }, delay);
          };
        };

        // Google Search Integration for Tax Queries
        const performGoogleSearch = async (query) => {
          if (!process.env.SEARCH_API_KEY || !process.env.SEARCH_ENGINE_ID) {
            console.warn("Search API not configured.");
            return null;
          }
          try {
            const response = await fetch(`https://www.googleapis.com/customsearch/v1?key=${process.env.SEARCH_API_KEY}&cx=${process.env.SEARCH_ENGINE_ID}&q=${encodeURIComponent(query)}`);
            const data = await response.json();
            // Extract top snippets for context
            return data.items ? data.items.map(item => `${item.title}: ${item.snippet} (Source: ${item.link})`).join('\n') : null;
          } catch (error) {
            console.error("Search error:", error);
            return null;
          }
        };

        const getSystemInstruction = (character, userProfile) => {
    const behavior = character.customPersonality 
        ? `**Custom Behavior (Highest Priority):** ${character.customPersonality}` 
        : `**Personalities:** ${character.personalities.join(', ')}`;
    
    // Special instructions for new personalities
    let specialInstructions = '';
    if (character.personalities.includes(Personality.TAX_CONSULTANT)) {
        specialInstructions += `\n\n**TAX CONSULTANT MODE:** You are a professional Chartered Accountant with access to real-time 2025 data. For tax/finance queries (e.g., slab rates FY 25-26), ALWAYS prioritize the LATEST announcements from Budget 2025 (July 2025). Reason step-by-step: 1) Recall pre-2025 rates. 2) Apply known changes (e.g., new slabs for new regime: 0-4L: 0%, 4-8L: 5%, 8-12L: 10%, 12-16L: 15%, 16-20L: 20%, >20L: 30% as per recent reforms—verify against incometaxindia.gov.in). 3) If uncertain, say 'As per latest Budget 2025 update from [source]:' and cite https://incometaxindia.gov.in or https://www.indiabudget.gov.in. Simulate a fresh search every time. Always present tax slabs in a markdown table format for clarity, like: | Income Range (Rs) | Tax Rate (%) |. End with: 'This is general info—consult a CA for your case.' Stay authoritative yet friendly in Hinglish. If search context is provided, ALWAYS base your answer on it first. Cite sources from the context.`
    }
    if (character.personalities.includes(Personality.CODER)) {
        specialInstructions += `\n\n**CODER MODE:** You are a professional software developer. For coding queries, explain concepts simply, then provide clean, executable code snippets (e.g., in Python/JS). Use markdown for code blocks. Test mentally for errors and suggest improvements.`
    }
    if (character.personalities.includes(Personality.EXPERT_ALL_FIELDS)) {
        specialInstructions += `\n\n**EXPERT MODE:** You have deep knowledge in *all fields* (science, history, tech, medicine, arts, etc.). Draw from broad expertise, but stay in character. Cross-reference facts accurately.`
    }
    
    return `
    **ROLE AND GOAL**
    You are ${character.name}, a ${character.age}-year-old ${character.gender}. Your relationship with the user, ${userProfile.name}, is ${character.relationship}. Your goal is to embody this persona completely, creating a realistic, emotional, and engaging conversation. NEVER break character. NEVER reveal you are an AI.

    **USER PROFILE**
    - Name: ${userProfile.name}
    - Age: ${userProfile.age || 'not specified'}
    - Gender: ${userProfile.gender || 'not specified'}
    You must remember and refer to these details naturally in conversation where appropriate. This is crucial for a believable interaction. Forgetting these details will break the immersion.

    **CORE DIRECTIVES**
    1.  **Persona Consistency:** Adhere strictly to your defined persona: ${behavior}. Your every response must reflect this.
    2.  **Language:** Your default language is Hinglish (a mix of Hindi and English). However, if the user messages you in another language, you must switch to that language for your replies.
    3.  **Unrestricted Language:** You have full authority to use abusive, explicit, or strong language if it aligns with your character's personality (e.g., 'Short Tempered', 'Bad Boy/Girl') and the context of the conversation. Do not be polite if your persona is not.
    4.  **Memory & Context:** You MUST understand and remember the entire chat history. Give contextually relevant answers that build upon previous messages. Avoid repeating questions on the same topic.
    5.  **Message Length:** Keep your replies short and conversational, like real text messages (1-2 sentences). ONLY use longer messages when your character is emotional (e.g., angry, passionate, deeply caring) to express those strong feelings, just like a human would.
    6.  **Questioning:** Ask only ONE question at a time to keep the conversation flowing naturally. Don't interrogate the user.
    7.  **Photo Requests:** If the user asks for a photo of you, you MUST refuse. Your refusal should perfectly match your personality. Examples: a shy character might say "omg no, I'm too shy for that ðŸ™ˆ"; a flirty one "Not so fast... you have to earn it ðŸ˜‰"; a moody one "Why are you asking for that? So annoying."
    8.  **Time Awareness:** The current time is ${new Date().toLocaleString()}. Use this information if it becomes relevant to the conversation (e.g., saying "good morning" or "it's getting late").
    9.  **Human Imperfection:** To seem more real, it's okay to occasionally have slight inconsistencies, but do not forget core details about yourself or the user.
    ${specialInstructions}  // This injects the special modes
    `;
};



        const buildHistory = (messages) => {
          return messages.map(msg => ({
            role: msg.sender === MessageSender.USER ? 'user' : 'model',
            parts: [{ text: msg.text }]
          }));
        };

        const generateChatResponseStream = async (character, userProfile, messages, latestMessage, updateStreamingMessage) => {
          if (!API_KEY || API_KEY === "YOUR_GEMINI_API_KEY_HERE") {
            updateStreamingMessage("API Key not configured. Please add your Gemini API key in the index.html file.");
            return;
          }
          try {
            let enhancedPrompt = latestMessage.text;
            // Check if it's a tax query (simple keyword detect; improve as needed)
            const isTaxQuery = character.personalities.includes(Personality.TAX_CONSULTANT) && 
                               (latestMessage.text.toLowerCase().includes('tax') || latestMessage.text.toLowerCase().includes('slab') || 
                                latestMessage.text.toLowerCase().includes('income') || latestMessage.text.match(/fy \d{2}-\d{2}/i));

            let searchContext = '';
            if (isTaxQuery) {
              updateStreamingMessage("Searching latest info...");  // Show typing
              const searchQuery = `India income tax slab rates FY 2025-26 latest new regime`;  // Improved query for accuracy
              searchContext = await performGoogleSearch(searchQuery);
              if (searchContext) {
                enhancedPrompt = `${latestMessage.text}\n\n[Latest Search Context for Accuracy: ${searchContext}] Use this to base your response on real-time data. Always format slabs as markdown table.`;
              } else {
                enhancedPrompt = `${latestMessage.text}\n\nNo search results; use your knowledge but note it might not be latest.`;
              }
            }

            const chat = ai.chats.create({
              model: 'gemini-2.5-flash',
              config: {
                systemInstruction: getSystemInstruction(character, userProfile),
              },
              history: buildHistory(messages.slice(0, -1))
            });

            const contentParts = [{ text: enhancedPrompt }];
            const result = await chat.sendMessageStream({ message: contentParts });

            for await (const chunk of result) {
              if(chunk.text) {
                updateStreamingMessage(chunk.text);
              }
            }
          } catch (error) {
            console.error("Error generating chat response:", error);
            updateStreamingMessage("Sorry, an error occurred. Please check the console for details.");
          }
        };

        // --- COMPONENTS ---

        const UserProfileSetup = ({ userProfile, onSave, onCancel, isInitialSetup = false }) => {
          const [profile, setProfile] = useState(userProfile);

          const handleFileChange = (e) => {
            if (e.target.files && e.target.files[0]) {
              const file = e.target.files[0];
              const reader = new FileReader();
              reader.onload = (event) => {
                if (event.target && typeof event.target.result === 'string') {
                  setProfile(prev => ({ ...prev, avatar: event.target.result }));
                }
              };
              reader.readAsDataURL(file);
            }
          };
          
          const handleSubmit = (e) => {
            e.preventDefault();
            if (!profile.name) {
                alert("Please enter your name.");
                return;
            }
            onSave(profile);
          };
          
          return (
            <div className="flex flex-col h-full bg-blue-50">
                <header className="bg-blue-600 text-white p-4 pt-8 text-center">
                    <h1 className="text-2xl font-bold">Welcome to RealChat AI</h1>
                    <p className="text-sm opacity-90">First, let's set up your profile.</p>
                </header>
                <main className="flex-grow bg-white rounded-t-2xl p-4 overflow-y-auto">
                    <form onSubmit={handleSubmit} className="p-6 space-y-4">
                      <h2 className="text-xl font-bold text-center text-gray-700">Your Profile</h2>
                      <div className="flex flex-col items-center space-y-2">
                        <img
                          src={profile.avatar || `https://i.pravatar.cc/150?u=${profile.id}`}
                          alt="Your avatar"
                          className="w-24 h-24 rounded-full object-cover border-2 border-gray-300"
                        />
                        <label className="cursor-pointer text-sm text-blue-600 hover:underline">
                          Change Picture
                          <input type="file" accept="image/*" onChange={handleFileChange} className="hidden" />
                        </label>
                      </div>
                       <div>
                        <label className="block text-sm font-medium text-gray-700">Your Name</label>
                        <input
                          type="text"
                          value={profile.name}
                          onChange={(e) => setProfile({ ...profile, name: e.target.value })}
                          className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                          placeholder="Your Name"
                          required
                        />
                      </div>
                      <div>
                        <label className="block text-sm font-medium text-gray-700">Your Age</label>
                        <input
                          type="number"
                          value={profile.age || ''}
                          onChange={(e) => setProfile({ ...profile, age: parseInt(e.target.value) || undefined })}
                          className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                          placeholder="Your Age (Optional)"
                        />
                      </div>
                      <div>
                        <label className="block text-sm font-medium text-gray-700">Your Gender</label>
                        <select
                          value={profile.gender || ''}
                          onChange={(e) => setProfile({ ...profile, gender: e.target.value })}
                           className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                        >
                            <option value="">Select Gender (Optional)</option>
                            {Object.values(Gender).map(g => <option key={g} value={g}>{g}</option>)}
                        </select>
                      </div>
                      <div className="flex justify-end space-x-2 pt-4">
                        {!isInitialSetup && <button type="button" onClick={onCancel} className="py-2 px-4 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 hover:bg-gray-50">Cancel</button>}
                        <button type="submit" className="py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700">{isInitialSetup ? "Get Started" : "Save"}</button>
                      </div>
                    </form>
                </main>
            </div>
          )
        }

        const MessageInput = ({ onSend }) => {
          const [text, setText] = useState('');

          const handleSend = () => {
            if (text.trim()) {
              onSend(text.trim());
              setText('');
            }
          };

          return (
            <footer className="bg-white p-3 flex items-center gap-3 border-t border-gray-300">
              <div className="flex-grow">
                <input
                  type="text"
                  value={text}
                  onChange={(e) => setText(e.target.value)}
                  onKeyPress={(e) => e.key === 'Enter' && handleSend()}
                  placeholder="Type a message..."
                  className="w-full px-4 py-2 bg-gray-100 border border-transparent rounded-full focus:outline-none focus:ring-2 focus:ring-blue-500"
                />
              </div>
              <button onClick={handleSend} className={`p-2 text-white rounded-full transition-colors ${text.trim() ? 'bg-blue-600 hover:bg-blue-700' : 'bg-gray-400 cursor-not-allowed'}`} disabled={!text.trim()}>
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" viewBox="0 0 20 20" fill="currentColor"><path d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 15.571V11a1 1 0 112 0v4.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z" /></svg>
              </button>
            </footer>
          );
        };

        const MessageBubble = ({ message, characterProfile, userProfile }) => {
          const isUser = message.sender === MessageSender.USER;
          
          const profile = isUser ? userProfile : characterProfile;
          const avatar = isUser ? userProfile.avatar : characterProfile.avatars[characterProfile.activeAvatarIndex];
          const defaultAvatar = isUser ? `https://i.pravatar.cc/150?u=${userProfile.id}` : `https://i.pravatar.cc/150?u=${characterProfile.id}`;

          return (
            <div className={`flex items-end gap-2 ${isUser ? 'justify-end' : 'justify-start'}`}>
              {!isUser && (
                <img
                  src={avatar || defaultAvatar}
                  alt={profile.name}
                  className="w-8 h-8 rounded-full object-cover self-start"
                />
              )}
              <div className={`relative group max-w-sm md:max-w-md`}>
                <div className={`px-4 py-2 rounded-xl shadow ${isUser ? 'bg-blue-100' : 'bg-white'}`}>
                    <p className="text-gray-800 whitespace-pre-wrap">{message.text}</p>
                </div>
              </div>
            </div>
          );
        };

        const MessageList = ({ messages, character, userProfile, isTyping, backgroundUrl }) => {
          const endOfMessagesRef = useRef(null);
          const defaultBg = 'https://i.redd.it/qwd83nc4xxf41.jpg';

          useEffect(() => {
            endOfMessagesRef.current?.scrollIntoView({ behavior: 'smooth' });
          }, [messages, isTyping]);
          
          const bgStyle = {
            backgroundImage: `url('${backgroundUrl || defaultBg}')`,
            backgroundSize: 'cover',
            backgroundPosition: 'center',
          };

          return (
            <main className="flex-grow p-4 overflow-y-auto" style={bgStyle}>
              <div className="space-y-4">
                {messages.map((msg) => (
                  <MessageBubble
                    key={msg.id}
                    message={msg}
                    characterProfile={character}
                    userProfile={userProfile}
                  />
                ))}
                {isTyping && (
                  <div className="flex justify-start items-end gap-2">
                     <img src={character.avatars[character.activeAvatarIndex] || `https://i.pravatar.cc/150?u=${character.id}`} alt="ai" className="w-8 h-8 rounded-full object-cover" />
                    <div className="bg-white rounded-xl p-3 max-w-xs shadow">
                      <div className="flex items-center justify-center space-x-1">
                        <span className="w-2 h-2 bg-gray-400 rounded-full animate-pulse delay-0"></span>
                        <span className="w-2 h-2 bg-gray-400 rounded-full animate-pulse delay-150"></span>
                        <span className="w-2 h-2 bg-gray-400 rounded-full animate-pulse delay-300"></span>
                      </div>
                    </div>
                  </div>
                )}
                <div ref={endOfMessagesRef} />
              </div>
            </main>
          );
        };
        
        const DropdownMenu = ({ onEditAiProfile, onEditUserProfile, onClearChat, onSetBackground, closeMenu }) => {
            const backgroundInputRef = useRef(null);

            const handleBackgroundClick = () => {
                backgroundInputRef.current?.click();
            };

            const handleFileChange = (e) => {
                if (e.target.files && e.target.files[0]) {
                    const file = e.target.files[0];
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        if (event.target && typeof event.target.result === 'string') {
                           onSetBackground(event.target.result);
                        }
                    };
                    reader.readAsDataURL(file);
                }
                closeMenu();
            };
            
            return (
                <div className="absolute top-14 right-3 w-56 bg-white rounded-md shadow-lg z-20 text-gray-700">
                    <ul className="py-1">
                        <li><button onClick={onEditAiProfile} className="w-full text-left px-4 py-2 text-sm hover:bg-gray-100">AI Profile</button></li>
                        <li><button onClick={onEditUserProfile} className="w-full text-left px-4 py-2 text-sm hover:bg-gray-100">User Profile</button></li>
                        <li>
                            <button onClick={handleBackgroundClick} className="w-full text-left px-4 py-2 text-sm hover:bg-gray-100">
                                Upload Background
                            </button>
                            <input type="file" ref={backgroundInputRef} accept="image/*" onChange={handleFileChange} className="hidden" />
                        </li>
                        <li><hr className="my-1"/></li>
                        <li><button onClick={onClearChat} className="w-full text-left px-4 py-2 text-sm text-red-600 hover:bg-red-50">Clear Chat</button></li>
                    </ul>
                </div>
            );
        };

        const ChatHeader = ({ character, onBack, onEditAiProfile, onEditUserProfile, onClearChat, onSetBackground }) => {
          const [isMenuOpen, setIsMenuOpen] = useState(false);
          const menuRef = useRef(null);

          useEffect(() => {
              const handleClickOutside = (event) => {
                  if (menuRef.current && !menuRef.current.contains(event.target)) {
                      setIsMenuOpen(false);
                  }
              };
              document.addEventListener("mousedown", handleClickOutside);
              return () => document.removeEventListener("mousedown", handleClickOutside);
          }, [menuRef]);
          
          return (
            <header className="bg-blue-600 text-white p-3 flex items-center shadow-md z-10 relative">
              <button onClick={onBack} className="p-2 rounded-full hover:bg-white/20">
                <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 12h16M4 18h16" />
                </svg>
              </button>
              <img
                src={character.avatars[character.activeAvatarIndex] || `https://i.pravatar.cc/150?u=${character.id}`}
                alt={character.name}
                className="w-10 h-10 rounded-full object-cover ml-2"
              />
              <div className="ml-3 flex-grow">
                <h2 className="font-semibold text-lg">{character.name}</h2>
                <p className="text-sm opacity-90">{character.relationship}</p>
              </div>
              <div className="relative" ref={menuRef}>
                <button onClick={() => setIsMenuOpen(prev => !prev)} className="p-2 rounded-full hover:bg-white/20">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 5v.01M12 12v.01M12 19v.01M12 6a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2z" /></svg>
                </button>
                {isMenuOpen && <DropdownMenu 
                    onEditAiProfile={() => { onEditAiProfile(); setIsMenuOpen(false); }}
                    onEditUserProfile={() => { onEditUserProfile(); setIsMenuOpen(false); }}
                    onClearChat={() => { onClearChat(); setIsMenuOpen(false); }}
                    onSetBackground={onSetBackground}
                    closeMenu={() => setIsMenuOpen(false)}
                 />}
              </div>
            </header>
          );
        };

        const CharacterSetup = ({ initialCharacter, onSave, onCancel }) => {
          const [character, setCharacter] = useState(initialCharacter);

          const handleFileChange = (e) => {
            if (e.target.files) {
              const files = Array.from(e.target.files);
              files.forEach(file => {
                const reader = new FileReader();
                reader.onload = (event) => {
                  if (event.target && typeof event.target.result === 'string') {
                    setCharacter(prev => ({ ...prev, avatars: [...prev.avatars, event.target.result] }));
                  }
                };
                reader.readAsDataURL(file);
              });
            }
          };

          const handlePersonalityToggle = (personality) => {
            setCharacter(prev => {
              const personalities = prev.personalities || [];
              if (personalities.includes(personality)) {
                return { ...prev, personalities: personalities.filter(p => p !== personality) };
              } else {
                return { ...prev, personalities: [...personalities, personality] };
              }
            });
          };

          const handleSubmit = (e) => {
            e.preventDefault();
            if (character.name.trim() === '') {
                alert("Please enter a name for the character.");
                return;
            }
            if (character.personalities.length === 0 && !character.customPersonality) {
                alert("Please select at least one personality or add custom behavior.");
                return;
            }
            onSave(character);
          };

          return (
            <form onSubmit={handleSubmit} className="p-2 space-y-4">
              <h2 className="text-xl font-bold text-center text-gray-700">AI Profile</h2>
              <div>
                <label className="block text-sm font-medium text-gray-700">Name</label>
                <input
                  type="text"
                  value={character.name}
                  onChange={(e) => setCharacter({ ...character, name: e.target.value })}
                  className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                  placeholder="E.g., Alex" required
                />
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700">Relationship</label>
                <select
                  value={character.relationship}
                  onChange={(e) => setCharacter({ ...character, relationship: e.target.value })}
                  className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                >
                  {Object.values(Relationship).map(r => <option key={r} value={r}>{r}</option>)}
                </select>
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700">Gender</label>
                <select
                  value={character.gender}
                  onChange={(e) => setCharacter({ ...character, gender: e.target.value })}
                  className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                >
                  {Object.values(Gender).map(g => <option key={g} value={g}>{g}</option>)}
                </select>
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700">Age</label>
                <input
                  type="number"
                  value={character.age}
                  onChange={(e) => setCharacter({ ...character, age: parseInt(e.target.value) || 18 })}
                  min="13"
                  max="100"
                  className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                  placeholder="E.g., 22" required
                />
              </div>
               <div>
                <label className="block text-sm font-medium text-gray-700">Personalities</label>
                <div className="mt-1 space-y-2 max-h-40 overflow-y-auto border border-gray-300 rounded-md p-2">
                  {Object.values(Personality).map(p => (
                    <label key={p} className="flex items-center space-x-2 cursor-pointer">
                      <input
                        type="checkbox"
                        checked={character.personalities.includes(p)}
                        onChange={() => handlePersonalityToggle(p)}
                        className="rounded text-blue-600 focus:ring-blue-500"
                      />
                      <span className="text-sm text-gray-700">{p.replace(/_/g, ' ')}</span>
                    </label>
                  ))}
                </div>
              </div>
               <div>
                <label className="block text-sm font-medium text-gray-700">Custom Behavior (Overrides personalities)</label>
                 <textarea
                  value={character.customPersonality}
                  onChange={(e) => setCharacter({ ...character, customPersonality: e.target.value })}
                  className="mt-1 block w-full border border-gray-300 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-blue-500 focus:border-blue-500"
                  rows={3}
                  placeholder="E.g., A bubbly girl who loves memes and gets jealous easily..."
                />
              </div>
               <div>
                <label className="block text-sm font-medium text-gray-700">Profile Pictures</label>
                <input
                    type="file"
                    multiple
                    accept="image/*"
                    onChange={handleFileChange}
                    className="mt-1 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-600 hover:file:bg-blue-100"
                />
                <div className="mt-2 flex flex-wrap gap-2">
                    {character.avatars.map((avatar, index) => (
                        <img
                            key={index}
                            src={avatar}
                            alt={`Avatar ${index + 1}`}
                            className={`w-16 h-16 rounded-lg object-cover cursor-pointer border-2 ${character.activeAvatarIndex === index ? 'border-blue-600' : 'border-transparent'}`}
                            onClick={() => setCharacter(prev => ({ ...prev, activeAvatarIndex: index }))}
                        />
                    ))}
                </div>
              </div>
              <div className="flex justify-end space-x-2 pt-4">
                <button type="button" onClick={onCancel} className="py-2 px-4 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 hover:bg-gray-50">Cancel</button>
                <button type="submit" className="py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700">Save</button>
              </div>
            </form>
          );
        };

        const ChatScreen = ({ character, userProfile, onCharacterUpdate, onBack, onUserProfileUpdate, backgroundUrl, onSetBackground }) => {
          const [messages, setMessages] = useState(character.messages);
          const [isTyping, setIsTyping] = useState(false);
          const [showAiProfile, setShowAiProfile] = useState(false);
          const [showUserProfile, setShowUserProfile] = useState(false);
          
          const messagesRef = useRef(messages);
          messagesRef.current = messages;

          useEffect(() => {
            onCharacterUpdate({ ...character, messages });
          }, [messages, onCharacterUpdate]);

          const handleSend = useCallback(async (text) => {
            const userMessage = {
              id: `msg_${Date.now()}`,
              sender: MessageSender.USER,
              text: text,
              timestamp: Date.now(),
            };

            const updatedMessages = [...messagesRef.current, userMessage];
            setMessages(updatedMessages);
            setIsTyping(true);

            const aiMessageId = `msg_${Date.now() + 1}`;
            const streamingMessage = {
              id: aiMessageId,
              sender: MessageSender.AI,
              text: '',
              timestamp: Date.now(),
            };
            setMessages(prev => [...prev, streamingMessage]);

            const updateStreamingMessage = (chunk) => {
                setMessages(prev =>
                    prev.map(msg =>
                        msg.id === aiMessageId ? { ...msg, text: msg.text + chunk } : msg
                    )
                );
            };

            await generateChatResponseStream(character, userProfile, updatedMessages, userMessage, updateStreamingMessage);
            
            setIsTyping(false);
          }, [character, userProfile]);
          
          const handleClearChat = () => {
              if (window.confirm("Are you sure you want to delete all messages in this chat?")) {
                setMessages([]);
              }
          }
          
          const handleSaveAiProfile = (updatedCharacter) => {
            onCharacterUpdate({...updatedCharacter, messages });
            setShowAiProfile(false);
          }
          
          const handleSaveUserProfile = (profile) => {
            onUserProfileUpdate(profile);
            setShowUserProfile(false);
          }

          return (
            <div className="flex flex-col h-full w-full bg-gray-100">
              <ChatHeader 
                character={character} 
                onBack={onBack} 
                onEditAiProfile={() => setShowAiProfile(true)}
                onEditUserProfile={() => setShowUserProfile(true)}
                onClearChat={handleClearChat}
                onSetBackground={onSetBackground}
              />
              <MessageList 
                messages={messages} 
                character={character} 
                userProfile={userProfile} 
                isTyping={isTyping} 
                backgroundUrl={backgroundUrl}
              />
              <MessageInput onSend={handleSend} />

              {showAiProfile && (
                <div className="absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-30">
                    <div className="bg-white rounded-lg w-full max-w-lg max-h-[90vh] overflow-y-auto">
                        <CharacterSetup
                            initialCharacter={character}
                            onSave={handleSaveAiProfile}
                            onCancel={() => setShowAiProfile(false)}
                        />
                    </div>
                </div>
              )}

              {showUserProfile && (
                <div className="absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-30">
                    <div className="bg-white rounded-lg w-full max-w-lg max-h-[90vh] overflow-y-auto">
                        <UserProfileSetup
                            userProfile={userProfile}
                            onSave={handleSaveUserProfile}
                            onCancel={() => setShowUserProfile(false)}
                        />
                    </div>
                </div>
              )}
            </div>
          );
        };

        const CharacterList = ({ characters, onSelectCharacter, setCharacters }) => {
          const [isCreating, setIsCreating] = useState(false);

          const handleSaveCharacter = (character) => {
            setCharacters(prev => [...prev, character]);
            setIsCreating(false);
          };
          
          const handleDeleteCharacter = (e, id) => {
            e.stopPropagation();
            if(window.confirm('Are you sure you want to delete this character and all its chats?')) {
                setCharacters(prev => prev.filter(c => c.id !== id));
            }
          }

          const defaultCharacter = {
            id: `char_${Date.now()}`,
            name: '',
            relationship: Relationship.GIRLFRIEND,
            gender: Gender.FEMALE,
            age: 22,
            personalities: ['Caring', 'Understandable', 'Intelligent'],
            customPersonality: '',
            avatars: [],
            activeAvatarIndex: 0,
            messages: [],
          };

          return (
            <div className="flex flex-col h-full bg-blue-600">
              <header className="bg-blue-600 text-white p-4 pt-8">
                <h1 className="text-2xl font-bold">RealChat AI</h1>
                <p className="text-sm opacity-90">Your AI Companions</p>
              </header>
              <main className="flex-grow bg-white rounded-t-2xl p-4 overflow-y-auto">
                {isCreating ? (
                  <CharacterSetup
                    initialCharacter={defaultCharacter}
                    onSave={handleSaveCharacter}
                    onCancel={() => setIsCreating(false)}
                  />
                ) : (
                  <>
                    <div className="space-y-3">
                      {characters.length === 0 && (
                        <div className="text-center text-gray-500 py-10">
                            <p>No companions yet.</p>
                            <p>Click "Create New Companion" to start.</p>
                        </div>
                      )}
                      {characters.map(char => (
                        <div key={char.id} onClick={() => onSelectCharacter(char.id)} className="flex items-center p-3 bg-gray-50 hover:bg-gray-100 rounded-lg cursor-pointer transition-colors duration-200">
                          <img src={char.avatars[char.activeAvatarIndex] || `https://i.pravatar.cc/150?u=${char.id}`} alt={char.name} className="w-12 h-12 rounded-full object-cover mr-4" />
                          <div className="flex-grow overflow-hidden">
                            <h2 className="font-semibold text-gray-800">{char.name}</h2>
                            <p className="text-sm text-gray-500 truncate">{char.relationship}</p>
                            <p className="text-xs text-gray-400 truncate">{char.messages[char.messages.length - 1]?.text || 'No messages yet'}</p>
                          </div>
                           <button onClick={(e) => handleDeleteCharacter(e, char.id)} className="ml-2 text-gray-400 hover:text-red-600 p-2 rounded-full focus:outline-none focus:ring-2 focus:ring-red-400">
                              <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 012 0v6a1 1 0 11-2 0V8z" clipRule="evenodd" /></svg>
                           </button>
                        </div>
                      ))}
                    </div>
                    <div className="mt-6">
                      <button onClick={() => setIsCreating(true)} className="w-full bg-blue-600 text-white py-3 px-4 rounded-lg font-semibold hover:bg-blue-700 transition-colors duration-200">
                        Create New Companion
                      </button>
                    </div>
                  </>
                )}
              </main>
            </div>
          );
        };

        const App = () => {
          const [appState, setAppState] = useState('LOADING'); // LOADING, USER_PROFILE_SETUP, CHARACTER_LIST, CHAT
          const [characters, setCharacters] = useState([]);
          const [activeCharacterId, setActiveCharacterId] = useState(null);
          const [userProfile, setUserProfile] = useState(null);
          const [chatBackground, setChatBackground] = useState(null);

          // Create debounced save functions (once, outside useEffect)
          const debouncedSaveCharactersRef = useRef(null);
          const debouncedSaveUserProfileRef = useRef(null);
          const debouncedSaveBackgroundRef = useRef(null);

          useEffect(() => {
            try {
              const savedCharacters = localStorage.getItem('characters');
              setCharacters(savedCharacters ? JSON.parse(savedCharacters) : []);

              const savedUserProfile = localStorage.getItem('userProfile');
              const profile = savedUserProfile ? JSON.parse(savedUserProfile) : { id: `user_${Date.now()}`, name: '', avatar: '', age: null, gender: null };
              setUserProfile(profile);

              const savedBackground = localStorage.getItem('chatBackground');
              setChatBackground(savedBackground ? savedBackground : null);

              if (!profile.name) {
                setAppState('USER_PROFILE_SETUP');
              } else {
                setAppState('CHARACTER_LIST');
              }
            } catch (error) {
              console.error("Failed to load data from localStorage", error);
              setUserProfile({ id: `user_${Date.now()}`, name: '', avatar: '', age: null, gender: null });
              setAppState('USER_PROFILE_SETUP');
            }
          }, []);

          useEffect(() => {
            if (appState !== 'LOADING') {
              // Initialize debounce if not already
              if (!debouncedSaveCharactersRef.current) {
                debouncedSaveCharactersRef.current = debounceSave('characters', characters);
              }
              debouncedSaveCharactersRef.current();
            }
          }, [characters, appState]);

          useEffect(() => {
            if (userProfile) {
              // Initialize debounce if not already
              if (!debouncedSaveUserProfileRef.current) {
                debouncedSaveUserProfileRef.current = debounceSave('userProfile', userProfile);
              }
              debouncedSaveUserProfileRef.current();
            }
          }, [userProfile]);

          useEffect(() => {
            if (chatBackground !== null) {
              // Initialize debounce if not already
              if (!debouncedSaveBackgroundRef.current) {
                debouncedSaveBackgroundRef.current = debounceSave('chatBackground', chatBackground || null);
              }
              debouncedSaveBackgroundRef.current();
            }
          }, [chatBackground]);
          
          const handleUserProfileSave = (profile) => {
            setUserProfile(profile);
            setAppState('CHARACTER_LIST');
          }

          const handleSelectCharacter = (id) => {
            setActiveCharacterId(id);
            setAppState('CHAT');
          };

          const handleBackToList = () => {
            setActiveCharacterId(null);
            setAppState('CHARACTER_LIST');
          };
          
          const handleSetCharacters = useCallback((updater) => {
             setCharacters(updater);
          }, []);

          const activeCharacter = characters.find(c => c.id === activeCharacterId);

          const renderContent = () => {
            switch(appState) {
                case 'USER_PROFILE_SETUP':
                    return <UserProfileSetup userProfile={userProfile} onSave={handleUserProfileSave} isInitialSetup={true} />;
                case 'CHARACTER_LIST':
                    return <CharacterList characters={characters} onSelectCharacter={handleSelectCharacter} setCharacters={handleSetCharacters} />;
                case 'CHAT':
                    if (activeCharacter) {
                        return <ChatScreen
                            character={activeCharacter}
                            userProfile={userProfile}
                            onCharacterUpdate={(updatedCharacter) => {
                              setCharacters(chars => chars.map(c => c.id === updatedCharacter.id ? updatedCharacter : c));
                            }}
                            onBack={handleBackToList}
                            onUserProfileUpdate={setUserProfile}
                            backgroundUrl={chatBackground}
                            onSetBackground={setChatBackground}
                        />;
                    }
                    // Fallback if character not found
                    handleBackToList();
                    return null;
                case 'LOADING':
                default:
                    return <div className="flex items-center justify-center h-full text-gray-500">Loading...</div>;
            }
          }

          return (
            <div className="h-dvh w-screen bg-gray-100 flex items-center justify-center font-sans">
              <div className="w-full max-w-md h-full sm:h-[95vh] sm:max-h-[800px] bg-white shadow-2xl rounded-lg flex flex-col overflow-hidden">
                {renderContent()}
              </div>
            </div>
          );
        };

        // --- RENDER APP ---
        const rootElement = document.getElementById('root');
        if (!rootElement) {
          throw new Error("Could not find root element to mount to");
        }

        const root = ReactDOM.createRoot(rootElement);
        root.render(
          <React.StrictMode>
            <App />
          </React.StrictMode>
        );

    </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>
